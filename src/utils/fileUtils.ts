import { ApiKey, FileOperationResult } from '../types';
import { apiServices } from '../data/apiServices';

/**
 * Parse .env file content into API keys
 */
export const parseEnvFile = (content: string): Record<string, ApiKey> => {
  const keys: Record<string, ApiKey> = {};
  const lines = content.split('\n');
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    // Skip empty lines and comments
    if (!trimmedLine || trimmedLine.startsWith('#')) {
      continue;
    }
    
    // Parse KEY=VALUE format
    const equalIndex = trimmedLine.indexOf('=');
    if (equalIndex === -1) {
      continue;
    }
    
    const key = trimmedLine.substring(0, equalIndex).trim();
    let value = trimmedLine.substring(equalIndex + 1).trim();
    
    // Remove quotes if present
    if ((value.startsWith('"') && value.endsWith('"')) || 
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }
    
    // Map environment variable names to service IDs
    const serviceId = mapEnvKeyToServiceId(key);
    if (serviceId && value) {
      keys[serviceId] = {
        id: serviceId,
        service: serviceId,
        value,
        isValid: undefined,
        lastTested: undefined,
        createdAt: new Date(),
        updatedAt: new Date()
      };
    }
  }
  
  return keys;
};

/**
 * Generate .env file content from API keys
 */
export const generateEnvContent = (keys: Record<string, ApiKey>): string => {
  const lines: string[] = [
    '# API Keys - Generated by API Key Manager',
    '# Do not commit this file to version control',
    ''
  ];
  
  // Group keys by category for better organization
  const categories = new Set(apiServices.map(s => s.category));
  
  for (const category of Array.from(categories).sort()) {
    const categoryServices = apiServices.filter(s => s.category === category);
    const categoryHasKeys = categoryServices.some(s => keys[s.id]?.value);
    
    if (categoryHasKeys) {
      lines.push(`# ${category.charAt(0).toUpperCase() + category.slice(1)} Services`);
      
      for (const service of categoryServices) {
        const key = keys[service.id];
        if (key?.value) {
          const envKey = mapServiceIdToEnvKey(service.id);
          lines.push(`${envKey}=${key.value}`);
        }
      }
      
      lines.push('');
    }
  }
  
  return lines.join('\n');
};

/**
 * Map environment variable names to service IDs
 */
const mapEnvKeyToServiceId = (envKey: string): string | null => {
  const mapping: Record<string, string> = {
    'OPENAI_API_KEY': 'openai',
    'ANTHROPIC_API_KEY': 'anthropic',
    'GITHUB_TOKEN': 'github',
    'GITHUB_API_KEY': 'github',
    'STRIPE_SECRET_KEY': 'stripe',
    'STRIPE_API_KEY': 'stripe',
    'BINANCE_API_KEY': 'binance',
    'COINBASE_API_KEY': 'coinbase',
    'SENDGRID_API_KEY': 'sendgrid',
    'TWILIO_AUTH_TOKEN': 'twilio',
    'TWILIO_API_KEY': 'twilio',
    'AWS_ACCESS_KEY_ID': 'aws',
    'AWS_SECRET_ACCESS_KEY': 'aws',
    'GOOGLE_CLOUD_API_KEY': 'google-cloud',
    'GOOGLE_API_KEY': 'google-cloud',
    'DISCORD_BOT_TOKEN': 'discord',
    'DISCORD_API_KEY': 'discord',
    'SLACK_BOT_TOKEN': 'slack',
    'SLACK_API_KEY': 'slack',
    'SUPABASE_ANON_KEY': 'supabase',
    'SUPABASE_SERVICE_ROLE_KEY': 'supabase'
  };
  
  return mapping[envKey.toUpperCase()] || null;
};

/**
 * Map service IDs to environment variable names
 */
const mapServiceIdToEnvKey = (serviceId: string): string => {
  const mapping: Record<string, string> = {
    'openai': 'OPENAI_API_KEY',
    'anthropic': 'ANTHROPIC_API_KEY',
    'github': 'GITHUB_TOKEN',
    'stripe': 'STRIPE_SECRET_KEY',
    'binance': 'BINANCE_API_KEY',
    'coinbase': 'COINBASE_API_KEY',
    'sendgrid': 'SENDGRID_API_KEY',
    'twilio': 'TWILIO_AUTH_TOKEN',
    'aws': 'AWS_ACCESS_KEY_ID',
    'google-cloud': 'GOOGLE_CLOUD_API_KEY',
    'discord': 'DISCORD_BOT_TOKEN',
    'slack': 'SLACK_BOT_TOKEN',
    'supabase': 'SUPABASE_ANON_KEY'
  };
  
  return mapping[serviceId] || `${serviceId.toUpperCase().replace('-', '_')}_API_KEY`;
};

/**
 * Import API keys from a .env file
 */
export const importFromEnvFile = async (): Promise<FileOperationResult> => {
  try {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }
    
    const result = await window.electronAPI.fs.openFile({
      filters: [
        { name: 'Environment Files', extensions: ['env'] },
        { name: 'Text Files', extensions: ['txt'] },
        { name: 'All Files', extensions: ['*'] }
      ]
    });
    
    if (!result.success || !result.content) {
      return {
        success: false,
        error: result.error || 'No file selected'
      };
    }
    
    const keys = parseEnvFile(result.content);
    const keyCount = Object.keys(keys).length;
    
    return {
      success: true,
      data: keys,
      message: `Successfully imported ${keyCount} API key${keyCount !== 1 ? 's' : ''}`
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
};

/**
 * Export API keys to a .env file
 */
export const exportToEnvFile = async (keys: Record<string, ApiKey>): Promise<FileOperationResult> => {
  try {
    if (!window.electronAPI) {
      throw new Error('Electron API not available');
    }
    
    const content = generateEnvContent(keys);
    const keyCount = Object.values(keys).filter(k => k.value).length;
    
    if (keyCount === 0) {
      return {
        success: false,
        error: 'No API keys to export'
      };
    }
    
    const result = await window.electronAPI.fs.saveFile({
      content,
      defaultPath: '.env'
    });
    
    if (!result.success) {
      return {
        success: false,
        error: result.error || 'Failed to save file'
      };
    }
    
    return {
      success: true,
      message: `Successfully exported ${keyCount} API key${keyCount !== 1 ? 's' : ''} to ${result.filePath}`
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
};

/**
 * Validate .env file content before import
 */
export const validateEnvContent = (content: string): { isValid: boolean; errors: string[]; warnings: string[] } => {
  const errors: string[] = [];
  const warnings: string[] = [];
  const lines = content.split('\n');
  
  let validKeyCount = 0;
  const seenKeys = new Set<string>();
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lineNumber = i + 1;
    
    // Skip empty lines and comments
    if (!line || line.startsWith('#')) {
      continue;
    }
    
    // Check for valid KEY=VALUE format
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      warnings.push(`Line ${lineNumber}: Invalid format, expected KEY=VALUE`);
      continue;
    }
    
    const key = line.substring(0, equalIndex).trim();
    const value = line.substring(equalIndex + 1).trim();
    
    // Check for empty key
    if (!key) {
      errors.push(`Line ${lineNumber}: Empty key name`);
      continue;
    }
    
    // Check for duplicate keys
    if (seenKeys.has(key)) {
      warnings.push(`Line ${lineNumber}: Duplicate key '${key}'`);
    }
    seenKeys.add(key);
    
    // Check for empty value
    if (!value) {
      warnings.push(`Line ${lineNumber}: Empty value for key '${key}'`);
      continue;
    }
    
    // Check if key is recognized
    const serviceId = mapEnvKeyToServiceId(key);
    if (serviceId) {
      validKeyCount++;
    } else {
      warnings.push(`Line ${lineNumber}: Unrecognized API key '${key}'`);
    }
  }
  
  if (validKeyCount === 0) {
    errors.push('No recognized API keys found in file');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
};

/**
 * Get supported environment variable names
 */
export const getSupportedEnvKeys = (): string[] => {
  return apiServices.map(service => mapServiceIdToEnvKey(service.id)).sort();
};

/**
 * Format file size for display
 */
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};